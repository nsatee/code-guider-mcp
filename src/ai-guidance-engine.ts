import { existsSync, readFileSync } from 'node:fs';
import type { CodeAnalysis, StorageInterface } from './storage-interface.js';
import type {
  GuidanceContext,
  VectorSearchResult,
  WorkflowStep,
} from './types.js';

export interface AIGuidanceResult {
  suggestions: string[];
  similarCode: VectorSearchResult[];
  suggestedWorkflows: VectorSearchResult[];
  suggestedTemplates: VectorSearchResult[];
  qualityIssues: string[];
  complexityScore: number;
  patterns: string[];
  recommendations: string[];
}

export interface CodePattern {
  name: string;
  description: string;
  confidence: number;
  suggestions: string[];
}

export class AIGuidanceEngine {
  private storage: StorageInterface;

  constructor(storage: StorageInterface) {
    this.storage = storage;
  }

  async analyzeCode(
    filePath: string,
    _context: GuidanceContext,
  ): Promise<AIGuidanceResult> {
    if (!existsSync(filePath)) {
      return this.getEmptyResult();
    }

    const content = readFileSync(filePath, 'utf8');
    const analysis = await this.performCodeAnalysis(filePath, content);

    // Save analysis to vector storage
    await this.storage.saveCodeAnalysis(analysis);

    // Get AI-powered suggestions
    const suggestions = await this.getCodeSuggestions(filePath, content);
    const similarCode = await this.findSimilarCode(filePath, content);
    const suggestedWorkflows = await this.findRelevantWorkflows(content);
    const suggestedTemplates = await this.findRelevantTemplates(content);
    const qualityIssues = await this.analyzeQualityIssues(content);
    const patterns = await this.detectPatterns(content);
    const recommendations = await this.generateRecommendations(
      analysis,
      patterns,
    );

    return {
      suggestions,
      similarCode,
      suggestedWorkflows,
      suggestedTemplates,
      qualityIssues,
      complexityScore: analysis.analysis.complexity,
      patterns,
      recommendations,
    };
  }

  private async performCodeAnalysis(
    filePath: string,
    content: string,
  ): Promise<CodeAnalysis> {
    const complexity = this.calculateComplexity(content);
    const patterns = await this.detectPatterns(content);
    const suggestions = await this.generateSuggestions(content, patterns);
    const qualityScore = this.calculateQualityScore(content);

    return {
      id: this.generateId(),
      filePath,
      content,
      embedding: [], // Will be generated by vector storage
      analysis: {
        complexity,
        patterns,
        suggestions,
        qualityScore,
      },
      createdAt: new Date().toISOString(),
    };
  }

  private calculateComplexity(content: string): number {
    const lines = content.split('\n').length;
    const functions = (
      content.match(/function\s+\w+|const\s+\w+\s*=\s*\(/g) || []
    ).length;
    const classes = (content.match(/class\s+\w+/g) || []).length;
    const conditionals = (content.match(/if\s*\(|switch\s*\(|case\s+/g) || [])
      .length;
    const loops = (content.match(/for\s*\(|while\s*\(|forEach|map\(/g) || [])
      .length;
    const imports = (content.match(/import\s+.*from/g) || []).length;

    // Simple complexity calculation
    const baseComplexity = lines * 0.1;
    const functionComplexity = functions * 2;
    const classComplexity = classes * 3;
    const controlComplexity = (conditionals + loops) * 1.5;
    const importComplexity = imports * 0.5;

    return Math.min(
      baseComplexity +
        functionComplexity +
        classComplexity +
        controlComplexity +
        importComplexity,
      100,
    );
  }

  private async detectPatterns(content: string): Promise<string[]> {
    const patterns: string[] = [];

    // React patterns
    if (content.includes('React') || content.includes('jsx')) {
      patterns.push('react-component');
    }
    if (content.includes('useState') || content.includes('useEffect')) {
      patterns.push('react-hooks');
    }
    if (content.includes('export default')) {
      patterns.push('default-export');
    }

    // API patterns
    if (content.includes('express') || content.includes('req, res')) {
      patterns.push('api-endpoint');
    }
    if (content.includes('async') && content.includes('await')) {
      patterns.push('async-function');
    }

    // TypeScript patterns
    if (content.includes('interface') || content.includes('type')) {
      patterns.push('typescript-types');
    }
    if (content.includes(': any')) {
      patterns.push('any-type-usage');
    }

    // Testing patterns
    if (
      content.includes('describe') ||
      content.includes('it(') ||
      content.includes('test(')
    ) {
      patterns.push('test-file');
    }

    // Error handling patterns
    if (content.includes('try') && content.includes('catch')) {
      patterns.push('error-handling');
    }
    if (content.includes('throw new Error')) {
      patterns.push('error-throwing');
    }

    return patterns;
  }

  private async generateSuggestions(
    content: string,
    patterns: string[],
  ): Promise<string[]> {
    const suggestions: string[] = [];

    // TypeScript suggestions
    if (content.includes(': any')) {
      suggestions.push(
        'Replace "any" type with specific TypeScript types for better type safety',
      );
    }

    // React suggestions
    if (patterns.includes('react-component') && !content.includes('React.FC')) {
      suggestions.push(
        'Consider using React.FC type for better component typing',
      );
    }

    // Error handling suggestions
    if (
      patterns.includes('async-function') &&
      !patterns.includes('error-handling')
    ) {
      suggestions.push(
        'Add try-catch blocks to async functions for proper error handling',
      );
    }

    // Import suggestions
    const unusedImports = this.findUnusedImports(content);
    if (unusedImports.length > 0) {
      suggestions.push(`Remove unused imports: ${unusedImports.join(', ')}`);
    }

    // Performance suggestions
    if (content.includes('map(') && !content.includes('key=')) {
      suggestions.push(
        'Add unique "key" prop to mapped React elements for better performance',
      );
    }

    return suggestions;
  }

  private findUnusedImports(content: string): string[] {
    const importMatches =
      content.match(/import\s+\{([^}]+)\}\s+from\s+['"][^'"]+['"]/g) || [];
    const unusedImports: string[] = [];

    for (const importMatch of importMatches) {
      const imports =
        importMatch
          .match(/\{([^}]+)\}/)?.[1]
          ?.split(',')
          .map((imp) => imp.trim()) || [];

      for (const importName of imports) {
        const cleanName = importName.replace(/\s+as\s+\w+/, '').trim();
        const regex = new RegExp(`\\b${cleanName}\\b`, 'g');
        const matches = content.match(regex) || [];

        if (matches.length <= 1) {
          // Only appears in import statement
          unusedImports.push(cleanName);
        }
      }
    }

    return unusedImports;
  }

  private calculateQualityScore(content: string): number {
    let score = 100;

    // Deduct points for common issues
    if (content.includes(': any')) score -= 20;
    if (content.includes('console.log')) score -= 5;
    if (content.includes('TODO') || content.includes('FIXME')) score -= 10;
    if (content.includes('eslint-disable')) score -= 15;

    // Add points for good practices
    if (content.includes('interface ') || content.includes('type '))
      score += 10;
    if (content.includes('try') && content.includes('catch')) score += 15;
    if (content.includes('test') || content.includes('spec')) score += 20;

    return Math.max(0, Math.min(100, score));
  }

  private async getCodeSuggestions(
    filePath: string,
    content: string,
  ): Promise<string[]> {
    const suggestions = await this.storage.getCodeSuggestions(
      filePath,
      content,
    );
    return suggestions.suggestedWorkflows.map(
      (w) => `Consider using workflow: ${w.metadata.name || w.id}`,
    );
  }

  private async findSimilarCode(
    filePath: string,
    content: string,
  ): Promise<VectorSearchResult[]> {
    return await this.storage.findSimilarCode(filePath, content, 5);
  }

  private async findRelevantWorkflows(
    content: string,
  ): Promise<VectorSearchResult[]> {
    return await this.storage.searchWorkflows(content, 5);
  }

  private async findRelevantTemplates(
    content: string,
  ): Promise<VectorSearchResult[]> {
    return await this.storage.searchTemplates(content, undefined, 5);
  }

  private async analyzeQualityIssues(content: string): Promise<string[]> {
    const issues: string[] = [];
    const qualityRules = await this.storage.listQualityRules();

    for (const rule of qualityRules) {
      if (rule.pattern) {
        const regex = new RegExp(rule.pattern, 'g');
        const matches = content.match(regex);
        if (matches) {
          issues.push(`${rule.name}: ${rule.description}`);
        }
      }
    }

    return issues;
  }

  private async generateRecommendations(
    analysis: CodeAnalysis,
    patterns: string[],
  ): Promise<string[]> {
    const recommendations: string[] = [];

    if (analysis.analysis.complexity > 50) {
      recommendations.push(
        'Consider breaking down this code into smaller, more manageable functions',
      );
    }

    if (patterns.includes('any-type-usage')) {
      recommendations.push(
        'Replace "any" types with specific TypeScript types for better type safety',
      );
    }

    if (analysis.analysis.qualityScore < 70) {
      recommendations.push(
        'Focus on improving code quality by addressing the identified issues',
      );
    }

    if (
      patterns.includes('react-component') &&
      !patterns.includes('test-file')
    ) {
      recommendations.push('Add unit tests for this React component');
    }

    if (
      patterns.includes('api-endpoint') &&
      !patterns.includes('error-handling')
    ) {
      recommendations.push(
        'Add comprehensive error handling to this API endpoint',
      );
    }

    return recommendations;
  }

  private getEmptyResult(): AIGuidanceResult {
    return {
      suggestions: [],
      similarCode: [],
      suggestedWorkflows: [],
      suggestedTemplates: [],
      qualityIssues: [],
      complexityScore: 0,
      patterns: [],
      recommendations: [],
    };
  }

  private generateId(): string {
    return Math.random().toString(36).substr(2, 9);
  }

  // Execute workflow with AI enhancements
  async executeWorkflowWithAI(
    workflowId: string,
    context: GuidanceContext,
    variables: Record<string, string> = {},
  ): Promise<{
    success: boolean;
    steps: Array<{
      step: WorkflowStep;
      result: string;
      success: boolean;
      aiSuggestions: string[];
    }>;
    errors: string[];
    aiInsights: string[];
  }> {
    const workflow = await this.storage.getWorkflow(workflowId);
    if (!workflow) {
      return {
        success: false,
        steps: [],
        errors: [`Workflow ${workflowId} not found`],
        aiInsights: [],
      };
    }

    const results: Array<{
      step: WorkflowStep;
      result: string;
      success: boolean;
      aiSuggestions: string[];
    }> = [];
    const errors: string[] = [];
    const aiInsights: string[] = [];

    // Sort steps by order
    const sortedSteps = [...workflow.steps].sort((a, b) => a.order - b.order);

    for (const step of sortedSteps) {
      try {
        const result = await this.executeStepWithAI(step, context, variables);
        const aiSuggestions = await this.generateStepSuggestions(
          step,
          context,
          variables,
        );
        results.push({
          step,
          result: result.result,
          success: true,
          aiSuggestions,
        });

        if (result.aiInsights) {
          aiInsights.push(...result.aiInsights);
        }
      } catch (error) {
        const errorMsg = `Step ${step.name} failed: ${error}`;
        errors.push(errorMsg);
        results.push({
          step,
          result: errorMsg,
          success: false,
          aiSuggestions: [],
        });
      }
    }

    return {
      success: errors.length === 0,
      steps: results,
      errors,
      aiInsights,
    };
  }

  private async executeStepWithAI(
    step: WorkflowStep,
    context: GuidanceContext,
    variables: Record<string, string>,
  ): Promise<{
    result: string;
    aiInsights?: string[];
  }> {
    // Basic step execution logic (simplified for this example)
    const result = `Executed step: ${step.name}`;
    const aiInsights = await this.generateStepSuggestions(
      step,
      context,
      variables,
    );

    return { result, aiInsights };
  }

  private async generateStepSuggestions(
    step: WorkflowStep,
    _context: GuidanceContext,
    _variables: Record<string, string>,
  ): Promise<string[]> {
    const suggestions: string[] = [];

    switch (step.action) {
      case 'create':
        suggestions.push('Consider adding TypeScript types to the new file');
        suggestions.push('Include proper error handling from the start');
        break;
      case 'modify':
        suggestions.push('Review existing code patterns before making changes');
        suggestions.push(
          'Ensure changes maintain consistency with the codebase',
        );
        break;
      case 'validate':
        suggestions.push(
          'Run additional quality checks beyond the basic validation',
        );
        break;
      case 'test':
        suggestions.push('Write comprehensive test cases covering edge cases');
        suggestions.push('Consider adding integration tests if applicable');
        break;
      case 'document':
        suggestions.push('Include code examples in the documentation');
        suggestions.push('Document any configuration options or parameters');
        break;
    }

    return suggestions;
  }
}
